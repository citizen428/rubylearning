2. The first version calls the method "mtdarry" which runs 10 times and prints the numbers 0-9. The second version prints the return value of the method after the execution of the method. This can be illustrated by changing the first program as follows (the output will now be the same as the output of the second version):

def mtdarry  
  10.times do |num| 
    puts num 
  end 
end 
  
x = mtdarry
puts x

Another way to illustrate the described behaviour is by changing the return value of the method "mtdarry" in the second version:

def mtdarry 
  10.times do |num| 
    puts num 
  end 
  "lala"
end 
 
puts mtdarry 

5. The program is inefficient in assigment, the use of unnecessary variables and an overly complex logical check. A more efficient version could look like this (given that the variables i, x and y need to be used):

i = x = y = 0
1000000.times do 
  i = x = y += 1
  puts x*y if (i == 100001)
end

An even more efficient version could do with a single variable:

1000000.times do |x|
  puts x**2 if (x == 100001)
end

6. The correct answer is 

  5. "#{title}" is #{price} yen. 

since the string is enclosed in single quotes (') no interpolation is done.

7. The operator "defined?" has a lower precedence than the assignment operator, so an undefined value gets assigned to the variable "expand". The idiomatic

puts expand ||= true

is probably the best way to do it.

8. The contents of x and y get swapped because Ruby assignments are done in parallel (See "Programming Ruby" - "Expressions" - "Assigment" - "Parallel Assignment").

9. The variable has been the left-hand side of an assignment, so the symbol is known (although nothing got assigned, hence the value "nil"). In this modified example

if false 
  x = pqr 
  pqr = foo
end 
puts x 
puts pqr
puts foo

we now get two "nil" values and an error on foo.

